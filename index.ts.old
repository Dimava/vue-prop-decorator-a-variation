import { PropType } from '@vue/runtime-core';
import { ExtractDefaultProps, ExtractProps, Vue, VueBase, PropOptions, createDecorator, DefaultFactory, prop } from 'vue-class-component';

export const isVueProp: unique symbol = Symbol('isVueProp');
export const propType: unique symbol = Symbol('rawType');
export const rawNullableType: unique symbol = Symbol('rawNullableType');
export const defaultValue: unique symbol = Symbol('defaultValue');
export const noDefaultValue: unique symbol = Symbol('noDefaultValue');
export const nullability: unique symbol = Symbol('nullability');
export const nunNullable: unique symbol = Symbol('nunNullable');


type OnlyNullable<T> = T extends null | undefined ? T : never;
type OptionalKeys<T> = { [K in keyof T]-?:
	({} extends { [P in K]: T[K] } ? K : never)
}[keyof T];
type Constructor = (new () => any) | SymbolConstructor;
type ConstructorOf<T> =
	| (T extends number ? Number : never)
	| (T extends string ? String : never)
	| (T extends boolean ? Boolean : never)
	| { new(...args: any[]): T };


/** blahs */
export type Prop<V
	, VDefault = typeof noDefaultValue
	, TNulls extends (typeof nunNullable | OnlyNullable<V> | null | undefined) = OnlyNullable<V> extends never ? typeof nunNullable : OnlyNullable<V>
	> = {
		[isVueProp]: true,
		[propType]: NonNullable<V>,
		[defaultValue]: VDefault,
		[nullability]: TNulls,
		[rawNullableType]: typeof nunNullable extends TNulls ? V : V | TNulls,
	} | (typeof nunNullable extends TNulls ? never : TNulls);


export type ExtractPropTypes<V extends VueBase>
	= {
		-readonly [K in keyof Required<V> as NonNullable<V[K]> extends { [isVueProp]: true } ? K : never]
		: NonNullable<V[K]> extends { [rawNullableType]: any } ? NonNullable<V[K]>[typeof rawNullableType] : never;
	};


/**
 * for `p0!: Prop<T>` returns `key: never`   
 * for `p1?: Prop<T>` returns `undefined`   
 * for `p2!: Prop<T,V>` returns `V`   
 */
export type ExtractDefaultPropTypes<V extends VueBase>
	= {
		-readonly [K in keyof ExtractPropTypes<V> & keyof V
		as K extends OptionalKeys<V> ? K :
		NonNullable<V[K]> extends { [defaultValue]: typeof noDefaultValue } ? never
		: K]
		: NonNullable<V[K]> extends { [defaultValue]: typeof noDefaultValue } ? undefined
		: NonNullable<V[K]> extends { [defaultValue]: any } ? NonNullable<V[K]>[typeof defaultValue]
		: never;
	};


// type VueValuePropDecorator = <V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
// 	(target: V, propertyKey: K) => void;
// type VueGetterPropDecorator = <V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
// 	(target: V, propertyKey: K, descriptor: TypedPropertyDescriptor<V[K]>) => typeof descriptor;
// type VuePropDecoratorFactory = (propOptions?: Constructor | Constructor[] | PropOptions) => VueValuePropDecorator & VueGetterPropDecorator;

type VuePropOptionsT<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V> = Constructor | Constructor[] | PropOptions<ExtractPropTypes<V>[K]>;


export declare interface PropOptionsStrict<T, D> {
	type?: ConstructorOf<T> | ConstructorOf<T>[];
	required?: boolean;
	default?: T extends Function ? (D) : (D | ((props: Record<string, unknown>) => T));
	validator?(value: unknown): value is T;
}

function configurePropGetterDescriptor<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>(
	target: V, propertyKey: K, descriptor: TypedPropertyDescriptor<V[K]>, propOptions: VuePropOptionsT<V, K> = {}
): typeof descriptor {
	if (!descriptor.get || descriptor.set) throw new Error('bad usage');
	let get = descriptor.get.bind(target);
	let decorator = createDecorator((componentOptions, key) => {
		componentOptions.props ??= Object.create(null);
		componentOptions.props[key] = Object.assign({ default: get }, propOptions);
	});
	descriptor.get = undefined;
	decorator(target, propertyKey as string);
	return descriptor;
}

function configurePropValue<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>(
	target: V, propertyKey: K, propOptions: VuePropOptionsT<V, K> = {}
): void {
	let decorator = createDecorator((componentOptions, key) => {
		componentOptions.props ??= Object.create(null);
		componentOptions.props[key] = Object.assign({}, propOptions);
	});
	decorator(target, propertyKey as string);
}

/** blah1 */
export function Prop<PType>(): { default<VDefault extends PType>(v: VDefault): Prop<PType, VDefault> };
/** blah 2 */
export function Prop<T, D>
	(propOptions: ConstructorOf<T> | ConstructorOf<T>[] | PropOptionsStrict<T, D>): {
		<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
			(target: V, propertyKey: K): void;
		<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
			(target: V, propertyKey: K, descriptor: TypedPropertyDescriptor<V[K]>): typeof descriptor;
	};
/** blah 3 */
export function Prop<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
	(target: V, propertyKey: K): void;
/** blah 4 */
export function Prop<V extends VueBase, K extends keyof ExtractPropTypes<V> & keyof V>
	(target: V, propertyKey: K, descriptor: TypedPropertyDescriptor<V[K]>): typeof descriptor;
export function Prop<PType, V extends VueBase = VueBase, K extends keyof ExtractPropTypes<V> & keyof V = never>(
	target?: V | VuePropOptionsT<V, K>, propertyKey?: K, descriptor?: TypedPropertyDescriptor<V[K]>
) {
	switch (arguments.length) {
		case 0:
			return { default<VDefault extends PType>(v: VDefault) { return v as unknown as Prop<PType, VDefault> } };
		case 3:
			return configurePropGetterDescriptor(target as V, propertyKey!, descriptor!);
		case 2:
			return configurePropValue(target as V, propertyKey!);
	}
	let propOptions = target as VuePropOptionsT<V, K>;
	function decorate(target: V, propertyKey: K): void;
	function decorate(target: V, propertyKey: K, descriptor: TypedPropertyDescriptor<V[K]>): typeof descriptor;
	function decorate(target: V, propertyKey: K, descriptor?: TypedPropertyDescriptor<V[K]>) {
		if (descriptor) return configurePropGetterDescriptor(target, propertyKey, descriptor, propOptions);
		return configurePropValue(target, propertyKey, propOptions);
	}
	return decorate;
}

prop